# goit-algo-hw-06
Master of Science (Neoversity): Algorithms and Data Structures- Homework №6

### Тест програми на наступному списку суміжностей:
    "A": {"B": 4, "C": 3},
    "B": {"A": 4, "D": 2},
    "C": {"A": 3, "E": 5},
    "D": {"B": 2, "F": 1},
    "E": {"C": 5, "F": 6},
    "F": {"D": 1, "E": 6, "G": 2, "H": 2},
    "G": {"F": 2, "H": 2},
    "H": {"F": 2, "G": 2}
### Результат візуалізації:
![image](https://github.com/user-attachments/assets/50f7ebcc-dd47-4634-93cf-77dd5bbede80)
### Аналіз характеристик:

- Кількість станцій (вершин): 8
- Кількість маршрутів (ребер): 9
- Ступені вершин (станції):
- Станція A: 2 маршрутів
- Станція B: 2 маршрутів
- Станція C: 2 маршрутів
- Станція D: 2 маршрутів
- Станція E: 2 маршрутів
- Станція F: 4 маршрутів
- Станція G: 2 маршрутів
- Станція H: 2 маршрутів
### Обхід до вузлу H з A за допомогою BFS:
- A
- B
- C
- D
- E
- F
- {'E', 'D', 'F', 'C', 'A', 'B'}

**Пояснення:** Алгоритм BFS шукає в ширину, тобто спочатку перевіряє всі сусідні вузли для кожного вузла. Починаємо з A, і спершу проходимо до B і C. На цьому рівні потрібного вузла немає, тому переходимо далі — до вузлів, які з'єднані з B і C, тобто до D і E. Так продовжуємо, доки не знайдемо вузол H. Останній вузол перед H був F.
### Обхід до вузлу H з A за допомогою DFS:
A
B
D
F
E
C
G
{'E', 'G', 'D', 'C', 'F', 'B', 'A'}
**Пояснення:** Алгоритм DFS шукає в глибину, тобто спочатку йде по одному шляху до кінця, перш ніж повернутися назад. Починаємо з A і рухаємося до B, потім з B до D, і далі до F. З F маємо кілька розгалужень, одне з яких — це шлях, з якого ми прийшли, тому його пропускаємо. Після цього алгоритм рухається вглиб через інші шляхи. Відвідуємо вузол E, потім повертаємося до C і далі до G. Обхід завершується на вузлі G, а перед цим було знайдено вузол F. З результатів видно, що DFS не гарантує найкоротший шлях.
